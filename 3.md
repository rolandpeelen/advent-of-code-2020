## 3a
Given the list of `..##......` elements, count how many `#` you come across when you go down the list and access a character at index I with a specific pattern.

### Thoughts
This seems to be rather trivial as well. I think we can fold the list, checking the elements at some index, and increment some counter accordingly. Then also keep track of the current offset and last offset.

In js, fully written out something like (not tested).
```javascript
arr.shift() // 3 right, 1 down. So
const { trees } = arr.reduce((acc, item) => {
  const hit = item[acc.offset] == "#";
  return {
  ...acc,
    trees: hit ? acc.trees + 1 : acc.trees,
    runningOffset: acc.runningOffset + offset
  }
}, {
  trees: 0
  offset: 3
  runningOffset
})
```

Lets see if we can do this in Haskell :sweat_smile:

--

So, I misread the problem. Instead of running out of list towards the right, it's more like an infinite set of repeating items. Not really a problem, doing a modulus on the list lenght will get you the correct index to take.

My solution is slightly hacky though. Because they stipulate a jump to the right by 3, and a jump down by 1, then taking that element. I have not encoded that behaviour at all, but simply go off the fact that in my dataset the element at my initial offset is 0. 

### 3b
As I expected, now it's time to do the actual work, we're going the have to jump in the list. Right now, I think it might be easier to encode all these in some sort of a coordinate system where I would have access to it by `x,y`, so I can iterate over the numbers. incrementing them as I go, instead of folding the list.
Let's have a brew :coffee: and a think...

```
-- So we need to go from this:
-- ...#....#.#...##......#.#...##.
-- .#..#...##..#....##........##..
-- ..##.##...##.#.#....#..#......#
-- ....#....#..#..#.#....#..###...
-- ####.....##.#.##...##..#....#..
-- To something like 
-- 0,1: '.'
-- 0,2: '.'
-- .... 
-- 4,0: '#' 
-- Question
```
I think, `list!!x!!y` would give me the same thing. Given the list of lists, I think I should be able to go for that.



